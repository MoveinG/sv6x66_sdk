#!/usr/bin/env python
# coding: utf8

#
# Copyright 2018 Ayla Networks, Inc.  All rights reserved.
#

#********************************************************************************
# This script is a server program written in Python. It is used for testing AL
# (Adapter Layer) interfaces of net-udp and net-stream (TCP or TLS). When "altest"
# program of PDA (Portable Device Agent) sends data to the server, the server
# simply sends the data back.
#
# The script is developed on Mac-book. The related packages and versions are
# listed below:
#     Python     3.6.5
#     tornado    5.0.2
# For testing net-stream of TLS, the following files should be placed in "certs"
# sub-directory under the directory that "altest-server.py" file located:
#     altest.aylanetworks.com.chain  --- Certificate chain
#     altest.aylanetworks.com.key    --- RSA private key
#     AylaTestCARoot.crt        --- Root Certificate
# These files are generated by Ayla and are used for "altest" only. The Certificate
# chain and the RSA private key are used by the server (altest-server.py). The Root
# Certificate should be installed on the device side to support TLS.
#********************************************************************************

from __future__ import absolute_import, division, print_function, with_statement
import errno
import os
import sys
import socket
import ssl
from tornado.log import app_log
from tornado.ioloop import IOLoop
from tornado.iostream import IOStream, SSLIOStream
from tornado.netutil import ssl_wrap_socket
from tornado import process
from tornado.netutil import set_close_exec

import tornado.web
import tornado.httpserver
from tornado.tcpserver import TCPServer
from tornado.iostream import StreamClosedError
from tornado import gen

TLS_PORT = 8889
TCP_PORT = 8888
UDP_PORT = 8887
CMD_PORT = 8886
MAX_PACKET_SIZE = 4096

gv_udp_srv_obj = None
gv_tcp_srv_obj = None
gv_tls_srv_obj = None

gb_udp_srv_started = False
gb_tcp_srv_started = False
gb_tls_srv_started = False
gb_tcp_srv_echo_on = False
gb_tls_srv_echo_on = False

#********************************************************************************
# A non-blocking, single-threaded UDP server
#********************************************************************************
class UDPServer(object):
  def __init__(self, rx_callback, io_loop=None):
    self.io_loop = io_loop
    self._sockets = {}   # fd -> socket object
    self._pending_sockets = [ ]
    self._started = False
    self.rx_callback = rx_callback

  def add_sockets(self, sockets):
    if self.io_loop is None:
      self.io_loop = IOLoop.instance()
    for sock in sockets:
      self._sockets[sock.fileno()] = sock
      self.add_recv_handler(sock, self.rx_callback, io_loop=self.io_loop)

  def bind(self, port, address=None, family=socket.AF_INET, backlog=25):
    sockets = self.bind_sockets(port, address=address, family=family, backlog=backlog)
    if self._started:
      self.add_sockets(sockets)
    else:
      self._pending_sockets.extend(sockets)

  def start(self, num_processes=1):
    assert not self._started
    self._started = True
    if num_processes != 1:
      process.fork_processes(num_processes)
    sockets = self._pending_sockets
    self._pending_sockets = [ ]
    self.add_sockets(sockets)

  def stop(self):
    for fd, sock in self._sockets.iteritems():
      self.io_loop.remove_handler(fd)
      sock.close()

  def bind_sockets(self, port, address=None, family=socket.AF_INET, backlog=25):
    sockets = []
    if address == "":
        address = None
    flags = socket.AI_PASSIVE
    if hasattr(socket, "AI_ADDRCONFIG"):
      flags |= socket.AI_ADDRCONFIG
    for res in set(socket.getaddrinfo(address, port, family, socket.SOCK_DGRAM, 0, flags)):
      af, socktype, proto, canonname, sockaddr = res
      sock = socket.socket(af, socktype, proto)
      set_close_exec(sock.fileno())
      if os.name != 'nt':
        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
      sock.setblocking(0)
      sock.bind(sockaddr)
      sockets.append(sock)
    return sockets

  def add_recv_handler(self, sock, callback, io_loop=None):
    if io_loop is None:
      io_loop = IOLoop.instance()
    def recv_handler(fd, events):
      while True:
        try:
          data, address = sock.recvfrom(2500)
        except socket.error as e:
          if e.args[0] in (errno.EWOULDBLOCK, errno.EAGAIN):
            return
          else:
            raise
        callback(sock, data, address)
      return
    io_loop.add_handler(sock.fileno(), recv_handler, IOLoop.READ)

#********************************************************************************
# UDP echo server
#********************************************************************************
def udp_data_recv_callback(sock, data, address):
  print( "UDP-RX: len = ", len(data) )
  # print( "UDP-RX: %s " % (data) )
  sock.sendto(data, 0, address)  # echo

def UDP_EchoServerStart():
  global gv_udp_srv_obj, gb_udp_srv_started
  if (gb_udp_srv_started):
    return None
  print( "UDP Server start." )
  gv_udp_srv_obj = UDPServer( udp_data_recv_callback )
  gv_udp_srv_obj.bind( port = UDP_PORT )
  gv_udp_srv_obj.start()
  gb_udp_srv_started = True

def UDP_EchoServerStop():
  global gv_udp_srv_obj, gb_udp_srv_started
  if (not gb_udp_srv_started):
    return None
  print( "UDP Server stop." )
  gv_udp_srv_obj.stop()
  del gv_udp_srv_obj
  gb_udp_srv_started = False

#********************************************************************************
# TCP echo server
#********************************************************************************
class TCP_EchoServer(TCPServer):
  @gen.coroutine
  def handle_stream(self, stream, address):
    global gb_tcp_srv_echo_on
    # ---- save the stream -----
    if stream.fileno().fileno() > 0:
      if not hasattr(self, 'client_streams'):
        self.client_streams = []
      self.client_streams.append(stream)
    # ----- do echo -----
    while True:
      try:
        #------- data = yield stream.read_until(b"\n") -------
        data = yield stream.read_bytes( num_bytes = MAX_PACKET_SIZE, partial = True )
        if (gb_tcp_srv_echo_on):
          print( "TCP-RX: len = ", len(data) )
          # print( "TCP-RX: %s " % (data) )
          yield stream.write( data )
      except StreamClosedError:
        print( "TCP client disconnected." )
        for connection in self.client_connections:
          if connection.fileno() < 0:
            self.client_connections.remove(connection)
        if len(self.client_streams) != 0:
          if stream in self.client_streams:
            self.client_streams.remove(stream)
        break

  def _handle_connection(self, connection, address):
    print( "TCP client connected." )
    # fd = connection.fileno()
    # print("  fd = ", fd)
    # ---- save the connection -----
    if not hasattr(self, 'client_connections'):
      self.client_connections = []
    self.client_connections.append(connection)
    TCPServer._handle_connection(self, connection, address)

def TCP_EchoServerStart():
  global gv_tcp_srv_obj, gb_tcp_srv_started, gb_tcp_srv_echo_on
  if (gb_tcp_srv_started):
    return
  print( "TCP Server start." )
  gv_tcp_srv_obj = TCP_EchoServer()
  gv_tcp_srv_obj.listen( TCP_PORT )
  gv_tcp_srv_obj.start()
  gb_tcp_srv_started = True
  gb_tcp_srv_echo_on = True

def TCP_EchoServerStop():
  global gv_tcp_srv_obj, gb_tcp_srv_started, gb_tcp_srv_echo_on
  if (not gb_tcp_srv_started):
    return
  print( "TCP Server stop." )
  if hasattr(gv_tcp_srv_obj, 'client_streams'):
    for streamx in gv_tcp_srv_obj.client_streams:
      # fd = streamx.fileno().fileno()
      gv_tcp_srv_obj.client_streams.remove(streamx)
      streamx.close()
  if hasattr(gv_tcp_srv_obj, 'client_connections'):
    for connection in gv_tcp_srv_obj.client_connections:
      connection.close()
  gv_tcp_srv_obj.stop()
  del gv_tcp_srv_obj
  gb_tcp_srv_started = False
  gb_tcp_srv_echo_on = False

def TCP_EchoServerSetEchol(enable):
  global gb_tcp_srv_echo_on
  if (enable != 0):
    print( "TCP Server echo ON.")
  else:
    print( "TCP Server echo OFF.")
  gb_tcp_srv_echo_on = enable

#********************************************************************************
# TLS echo server
#********************************************************************************
class TLS_EchoServer(TCPServer):
  @gen.coroutine
  def handle_stream(self, stream, address):
    global gb_tls_srv_echo_on
    # ---- save the stream -----
    if stream.fileno().fileno() > 0:
      if not hasattr(self, 'client_streams'):
        self.client_streams = []
      self.client_streams.append(stream)
    # ----- do echo -----
    while True:
      try:
        #------- data = yield stream.read_until(b"\n") -------
        data = yield stream.read_bytes( num_bytes = MAX_PACKET_SIZE, partial=True)
        if (gb_tls_srv_echo_on):
          print( "TLS-RX: len = ", len(data) )
          # print( "TLS-RX: %s " % (data) )
          yield stream.write(data)
      except StreamClosedError:
        print( "TLS client disconnected." )
        for connection in self.client_connections:
          if connection.fileno() < 0:
            self.client_connections.remove(connection)
        if len(self.client_streams) != 0:
          if stream in self.client_streams:
            self.client_streams.remove(stream)
        break

  def _handle_connection(self, connection, address):
    print( "TLS client connected." )
    # fd = connection.fileno()
    # print("  fd = ", fd)
    # ---- save the connection -----
    if not hasattr(self, 'client_connections'):
      self.client_connections = []
    self.client_connections.append(connection)
    TCPServer._handle_connection(self, connection, address)

def TLS_EchoServerStart():
  global gv_tls_srv_obj, gb_tls_srv_started, gb_tls_srv_echo_on
  if (gb_tls_srv_started):
    return
  print( "TLS Server start." )
  # print(sys.argv)
  for s in sys.argv:
    if s.find("altest-server.py") < 0:
      continue
    fpath = s.replace("altest-server.py", "", 1)
    break
  srv_cert_chain_file  = fpath + "certs/altest.aylanetworks.com.chain"
  srv_rsa_prv_key_file = fpath + "certs/altest.aylanetworks.com.key"
  gv_tls_srv_obj = TLS_EchoServer(
    ssl_options = dict(
      certfile = srv_cert_chain_file,
      keyfile = srv_rsa_prv_key_file
    )
  )
  gv_tls_srv_obj.listen( TLS_PORT )
  gb_tls_srv_started = True
  gb_tls_srv_echo_on = True

def TLS_EchoServerStop():
  global gv_tls_srv_obj, gb_tls_srv_started, gb_tls_srv_echo_on
  if (not gb_tls_srv_started):
    return
  print( "TLS Server stop." )
  if hasattr(gv_tls_srv_obj, 'client_streams'):
    for streamx in gv_tls_srv_obj.client_streams:
      # fd = streamx.fileno().fileno()
      gv_tls_srv_obj.client_streams.remove(streamx)
      streamx.close()
  if hasattr(gv_tls_srv_obj, 'client_connections'):
    for connection in gv_tls_srv_obj.client_connections:
      connection.close()
  gv_tls_srv_obj.stop()
  del gv_tls_srv_obj
  gb_tls_srv_started = False
  gb_tls_srv_echo_on = False

def TLS_EchoServerSetEcho(enable):
  global gb_tls_srv_echo_on
  if (enable != 0):
    print( "TLS Server echo ON.")
  else:
    print( "TLS Server echo OFF.")
  gb_tls_srv_echo_on = enable

#********************************************************************************
# UDP control server
#********************************************************************************
def udp_ctrl_recv_callback(sock, data, address):
  # print(data)
  if (data == b"tcp_connect_enable\n"):
    TCP_EchoServerStart()
  elif (data == b"tcp_connect_disable\n"):
    TCP_EchoServerStop()
  elif (data == b"tcp_echo_enable\n"):
    TCP_EchoServerSetEchol(True)
  elif (data == b"tcp_echo_disable\n"):
    TCP_EchoServerSetEchol(False)
  elif (data == b"tls_connect_enable\n"):
    TLS_EchoServerStart()
  elif (data == b"tls_connect_disable\n"):
    TLS_EchoServerStop()
  elif (data == b"tls_echo_enable\n"):
    TLS_EchoServerSetEcho(True)
  elif (data == b"tls_echo_disable\n"):
    TLS_EchoServerSetEcho(False)
  elif (data == b"udp_echo_enable\n"):
    UDP_EchoServerStart()
  elif (data == b"udp_echo_disable\n"):
    UDP_EchoServerStop()
  else:
    print("Unknown UDP Command: %s", (data) )

def UDP_CtrlServerStart():
  udp_ctrl_srv_obj = UDPServer( udp_ctrl_recv_callback )
  udp_ctrl_srv_obj.bind( port = CMD_PORT )
  udp_ctrl_srv_obj.start()

#********************************************************************************
#
#********************************************************************************
if __name__ == "__main__":
  TCP_EchoServerStart()
  TLS_EchoServerStart()
  UDP_EchoServerStart()
  UDP_CtrlServerStart()
  IOLoop.current().start()
